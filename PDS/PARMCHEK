*          PARM CHECKER        AT LEVEL 1.3 AS OF 05/29/02
   TITLE 'PARMCHEK -- SET PARM BITS USING A TABLE'
**************************************************************
**************************************************************
**                                                          **
**                                                          **
**  MODULE:   PARMCHEK - Set option bits, based on          **
**                       keywords coded in PARM and/or      **
**                       SYSIN.                             **
**                                                          **
**  AUTHOR:   Sam Golob                                     **
**                                                          **
**  PURPOSE:  This program converts keywords in a PARM      **
**            field or in SYSIN, into bit settings that     **
**            a program can use, to control options in      **
**            its execution.                                **
**                                                          **
**            This program can be run as a subroutine       **
**            which is called, to set up to 5 bytes of      **
**            bits, up to 40 bits in all, based on the      **
**            settings of keywords in a table.              **
**                                                          **
**            This routine makes it easy to put a lot of    **
**            options into a program.  If you want to       **
**            add options, or use other words in PARM or    **
**            SYSIN to call the same options, all you       **
**            have to do, is to change or add entries in    **
**            a table.  There is no extra coding to be      **
**            done.                                         **
**                                                          **
**            Keywords in the PARM or SYSIN areas do not    **
**            have to be delimited by commas or spaces or   **
**            anything else.  Although for clarity, I'd     **
**            certainly recommend that you put commas or    **
**            spaces between the PARM field keywords.       **
**            Therefore, I'd also advise that when you      **
**            design keywords to put into the table to      **
**            designate options, that you make them         **
**            significantly different from each other.      **
**            There is a length field in the table,         **
**            however, which gives you some more control    **
**            in this area.                                 **
**                                                          **
**            From a calling program, it would be possible  **
**            to call PARMCHEK twice, against two different **
**            tables, to set 10 bytes of options, instead   **
**            of 5 bytes of options, and so forth...        **
**                                                          **
**            This gives you the opportunity of having      **
**            a tremendous number of options, set by        **
**            keywords, in your program, without using      **
**            up valuable "base register space" for such    **
**            coding.                                       **
**                                                          **
**                                                          **
**  METHOD:   Bits, in the 5 bytes of PARMFLGS, are set,    **
**            from a table, based on assembled defaults.    **
**            These default settings are then overridden    **
**            from a scan of words in the PARM field of     **
**            the EXEC card.                                **
**                                                          **
**            If a SYSIN DD card is present, its cards      **
**            are scanned against the table entries, to     **
**            further override the bit settings which       **
**            have already been done by the defaults and    **
**            the PARM field.                               **
**                                                          **
**            The main purpose of this routine is to set    **
**            bits from words.  However, if you need some   **
**            keywords with values, such as (for example)   **
**            FILELIMIT=69  in your program, you may use    **
**            the "user code" section of this program       **
**            to code that stuff in, so that these special  **
**            keywords can be coded in SYSIN.               **
**                                                          **
**            Two sample keywords expecting number values:  **
**            FILELIMIT=nnn  or                             **
**            LABELIMIT=mmm                                 **
**            have been coded here, just to illustrate      **
**            how the user coding might work.               **
**                                                          **
**            Search order is:  Defaults, then PARM in      **
**            the EXEC card, then SYSIN.                    **
**                                                          **
**            As coded here, the FILELIMIT= and             **
**            LABELIMIT= keywords in SYSIN have to be in    **
**            column 1 of the SYSIN cards, and if these     **
**            "special keywords" are present in a card,     **
**            the rest of that card is not scanned for      **
**            the table keywords.                           **
**                                                          **
**            As coded here, the PARMTABL is a separate     **
**            CSECT, addressable by V-CONs from the         **
**            PARMCHEK CSECT.                               **
**                                                          **
**            It would probably be best to invoke the       **
**            PARMCHEK program as a separate CSECT which    **
**            is linkedited with the calling program,       **
**            but it may be LOADed and BALR 14,15 'ed to,   **
**            and run as a separate program.  (See the      **
**            PARMDRVR program that is included in this     **
**            package, as a sample.)                        **
**                                                          **
**    Input:  A fullword containing the address of the      **
**            saved Register 1 from the calling program,    **
**            which points to its parms.                    **
**                                                          **
**            A table containing parms, which is coded      **
**            according to the following rules, and which   **
**            has entries of 15 bytes apiece.               **
**                                                          **
**      FORMAT OF THE PARM TABLE                            **
**                                                          **
**        ONE ENTRY IS 15 BYTES                             **
**                                                          **
**          1ST BYTE:      LENGTH OF THIS PARM WORD IN HEX  **
**                         (This is the word which          **
**                          controls the bit settings.)     **
**                         (up to and including 8 bytes)    **
**                                                          **
**          2ND BYTE:      X'01' says turn bit flag(s) OFF  **
**                         X'00' says turn bit flag(s) ON   **
**                         X'10' set entry as a DEFAULT     **
**                                                          **
**          NEXT 8 BYTES:  PARM NAME - LEFT JUSTIFIED       **
**                         (This is the word searched on,   **
**                          in the EXEC PARM and SYSIN      **
**                          areas.)                         **
**                                                          **
**          NEXT 5 BYTES:  FLAG BIT settings controlled by  **
**                          this keyword.                   **
**                                                          **
**                         These are the bits which the     **
**                          keyword will flip on (or off).  **
**                                                          **
**                         You may control multiple bits    **
**                          using one keyword.  All bits    **
**                          controlled by this keyword      **
**                          are coded in this entry field.  **
**                                                          **
**          The table is ended by an entry of X'FF's.       **
**                                                          **
**                                                          **
**    Output:  R1 points to a 5-byte area containing the    **
**             40 switch settings.                          **
**                                                          **
**             Sample code to use PARMCHEK output:          **
**                                                          **
**                      ST    R1,PARMADDR                   **
**                      USING PARMFLGS,R1                   **
**             *                                            **
**             PARMFLGS DSECT                               **
**             PARMFLG1 DS    X                             **
**             PARMFLG2 DS    X                             **
**             PARMFLG3 DS    X                             **
**             PARMFLG4 DS    X                             **
**             PARMFLG5 DS    X                             **
**                                                          **
**               then ....                                  **
**                                                          **
**                      TM    PARMFLG2,X'04'                **
**                      BZ    some location                 **
**                        ....                              **
**                                                          **
**             R2 points to the address of a data area      **
**             containing values generated by this          **
**             program.  It's address is at label STRTVALU  **
**             and its length is in the first fullword      **
**             at STRTVALU.                                 **
**                                                          **
**             R2 is accessed in a similar manner to R1.    **
**             See the PARMDRVR program for an example      **
**             illustrating one way in which PARMCHEK       **
**             may be called.                               **
**                                                          **
**                                                          **
**************************************************************
         EJECT
**************************************************************
**                                                          **
**  CHANGE LOG:                                             **
**                                                          **
**    Version 1.1 - Separate Parm Table into different      **
**       CSECT.  Detailed reporting in PARMREPT ddname.     **
**                                                          **
**    Version 1.2 - Uppercase keyword before comparing      **
**       against the table entries.  This assumes you       **
**       will code your table with all uppercase keyword    **
**       entries.                                           **
**                                                          **
**    Version 1.3 - Option for requiring commas or spaces   **
**       as delimiters between parms.  Comment out one      **
**       instruction to require delimiters.                 **
**                                                          **
**************************************************************
**************************************************************
         EJECT
**************************************************************
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.
*  ---------------------------------------------------------------  *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R4,SAV4HEX
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAV4HEX
         LM    15,1,HEXSAVE
         MEND
         SPACE
**************************************************************
         GBLC  &LLEV
&LLEV    SETC  '1.3 '
         YREGS
PARMCHEK CSECT
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'PARMCHEK - SET BITS FROM PARM KEYWORDS '
         DC    C' - '
         DC    C'PARM INPUT IN SYSIN '
         DC    C' - '
         DC    C'LEVEL '
SYSLEV   DC    C'&LLEV'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME ',C'--- '
         DC    C'Copyright (c) 2001 by Sam Golob '
         DC    C'--- '            MAKE EYECATCHER VISIBLE
SAVEAREA DC    18F'0'
EYECATCH DS    0D             ENSURE ALIGNMENT
         SAVE  (14,12)
         LR    R5,R1          SAVE PARM POINTER
         LA    R1,SAVEAREA          NEW SAVE-AREA ADDR
         ST    R1,8(,R13)           FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)           BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1               NEW SAVE AREA ADDRESS
         DROP  R15
* -----                       SET UP BASE REGISTERS
         USING PARMCHEK,R12,R11,R10
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LR    R1,R5          RESTORE PARM POINTER
         ST    R1,PARMSAVE
* ----------------------------------------------------------------- *
TIOTSCAN DS    0H             Determine the presence of Optional
*                             DDNAMES:  SYSIN AND PARMREPT.
* ----->                      OPEN them if there is JCL for them.
* ----------------------------------------------------------------- *
         L     R5,16          R5=CVT
         L     R5,0(,R5)      R5=TCB WORDS
         L     R5,4(,R5)      R5=MY TCB
         L     R5,12(,R5)     R5=TIOT
         LA    R5,24(,R5)     R5=FIRST DD ENTRY
TIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?
         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES
         CLC   4(8,R5),PARMREPT+40  PARMREPT DDNAME THERE?
         BNE   TIOTSYSN       NO
         OI    FLAGSYST,X'01'       SHOW PRESENCE OF PARMREPT DD
         B     TIOTNEXT       CONTINUE
TIOTSYSN CLC   4(8,R5),SYSIN+40
         BNE   TIOTNEXT
         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSIN    DD
         B     TIOTNEXT
TIOTNEXT SR    R3,R3
         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY
         AR    R5,R3          R5=NEXT DD ENTRY
         B     TIOTLOOP       GO CHECK IT
TIOTSEND DS    0H
***********************************************************************
* GET SYSTEM DATE AND TIME - A standard way to get date and time      *
***********************************************************************
         STM   R14,R2,SAVE1402
         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY
         OI    DATE+4,X'0F'
         UNPK  DATED,DATE
         OI    TIME+3,X'0F'
         UNPK  TIMED,TIME
*                          FILL HEADDATE AREA WITH INFO TO REUSE
         MVC   HEADDATE(2),DATED
         MVI   HEADDATE+2,C'/'
         MVC   HEADDATE+3(2),DATED+2
         MVI   HEADDATE+5,C'/'
         MVC   HEADDATE+6(4),DATED+4
         MVC   HEADDATE+12(2),TIMED
         MVI   HEADDATE+14,C':'
         MVC   HEADDATE+15(2),TIMED+2
         MVI   HEADDATE+17,C':'
         MVC   HEADDATE+18(2),TIMED+4
         MVC   MESSAGE1+98(31),HEADDLIT    TODAY'S DATE AND TIME
         LM    R14,R2,SAVE1402
***********************************************************************
         MVC   LEVDATE(8),SYSDAT
***********************************************************************
         MVC   MESSAGE1+71(21),LEVELLIT    PROGRAM LEVEL AND
* ----------------------------------------------------------------- *
INITCONS DS    0H
         ZAP   TOTMLCNT,=P'0'
* ----------------------------------------------------------------- *
CHEKPRNT DS    0H
         TM    FLAGSYST,X'01'
         BZ    CHEKPREN
         OPEN  (PARMREPT,OUTPUT)
         OI    OPENDFLG,X'01'
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE,MESSAGE1
         PUT   PARMREPT,MESSAGE1
         MVC   PRTLINE,PRTLINE-1
         PUT   PARMREPT,PRTLINE
CHEKPREN DS    0H
* ----------------------------------------------------------------- *
* --------------------------------------------------------- *
PARMCHK  DS    0H         CHECK PARMS AND FLAG THEIR
*                         PRESENCE OR ABSENCE.
*            (PERMISSIBLE PARMS ARE CODED IN PARMTABL.)
PARMINIT L     R1,PARMSAVE    SAVED PARM POINTER
         L     R1,0(,R1)      Get PARM field
         LH    R5,0(,R1)      SAVE PARM LENGTH
         ST    R5,PARMSLEN    STORE FULLWORD VALUE
         MVC   SAVMSLEN,PARMSLEN
         L     R2,=V(PARMTABL)  LOAD START OF PARM TABLE
         LA    R4,2(,R1)      POINT TO START OF JCL PARMS
         ST    R4,PARMSTRT    PUT ADDRESS INTO PGM STORAGE
         LA    R1,0           USE R1 TO MEASURE LENGTH READ
* -----------------------------------------------------------
*   ONE PASS THRU PARM TABLE TO SET DEFAULT ENTRIES BEFORE
*   LOOKING AT JCL OVERRIDES TO THE PARMS.
* -----------------------------------------------------------
PARMDFLT DS    0H             SET DEFAULTS FROM PARM TABLE
         CLI   0(R2),X'FF'    END OF PARM TABLE?
         BE    PARMDEND       YES. DEFAULTS SET. CHECK PARMS.
         TM    1(R2),X'10'    IS THIS ENTRY A DEFAULT?
         BO    PARMDSET       YES, GO SET IT.
         LA    R2,PTELEN(,R2)  NO. BOP TO TEST NEXT ENTRY,
         B     PARMDFLT       AND LOOP UNTIL TABLE ENDS.
PARMDSET TM    1(R2),X'01'    DO WE TURN THIS FLAG OFF?
         BO    PARMDOFF       YES. FLAGS ARE TURNED OFF..
         OC    PARMFLGS(PBYTES),PTEFLG(R2) NO. FLAG IS TURNED ON.
         LA    R2,PTELEN(,R2)  NO. BOP TO TEST NEXT ENTRY,
         B     PARMDFLT       CHECK MORE TABLE ENTRIES.
PARMDOFF MVC   PARMFWRK(PBYTES),PTEFLG(R2)  PARM BYTES TO WRK
         XC    PARMFWRK(PBYTES),EFFS        FLIP PARM BYTES
         NC    PARMFLGS(PBYTES),PARMFWRK    TURN PARM BYTE(S) OFF
         LA    R2,PTELEN(,R2)  NO. BOP TO TEST NEXT ENTRY,
         B     PARMDFLT   LOOP BACK TILL ONE PASS THRU TABLE
PARMDEND LA    R1,0           INITIALIZE COUNTING REGISTER
         L     R2,=V(PARMTABL)  LOAD START OF PARM TABLE
         L     R4,PARMSTRT    GET ADDRESS FROM PGM STORAGE
* ----------------------------------------------------------------- *
SCANPARM DS    0H
         ST    R7,SAVE7BA0
         ZAP   PARMLCNT,=P'0'
         ZAP   PARMHITS,=P'0'
         BAL   R7,PARMLOOP      Now check the PARM field
         MVC   SAVPHITS,PARMHITS
         MVC   SAVCHRCT,PRMCHRCT
         MVC   SAVELCNT,PARMLCNT
         AP    TOTMHITS,PARMHITS
         AP    TOTMLCNT,PARMLCNT
         L     R7,SAVE7BA0
* ----------------------------------------------------------------- *
OPNSYSIN TM    FLAGSYST,X'02'   Are we checking SYSIN?
         BZ    OPNSYSNE         NO. GO FURTHER IN PROCESSING
         OPEN  (SYSIN,INPUT)
         TM    SYSIN+48,X'10'        IS THE DD OPEN  ?
         BZ    NOSYSIN        NO. FLAG THE ERROR & MESSAGE
         OI    OPENDFLG,X'02'     FLAG THAT SYSIN IS OPEN
         B     OPNSYSNE           AND CONTINUE PROCESSING.
NOSYSIN  DS    0H
         B     CARDREND
OPNSYSNE DS    0H
* ----------------------------------------------------------------- *
CHEKCARD TM    FLAGSYST,X'02'     TEST IF SYSIN IS PRESENT
         BZ    CHECKEND           ISN'T. NO POINT TO READ CARDS.
         TM    OPENDFLG,X'02'     IS SYSIN OPEN ?
         BZ    CHECKEND           ISN'T THERE SO CAN'T LOOK AT IT.
CARDREAD DS    0H              CHECK SYSIN FOR KEYWORDS AND PARMS
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*              Insert User Code Here for Keywords
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         GET   SYSIN,CARDIN
*
* -- >>              <-- Intercept any keywords you want in SYSIN -->
* -- >>              <--    before you start the table scan       -->
*
         CLC   =C'FILELIMIT=',CARDIN    KEYWORD PRESENT IN THIS CARD?
         BE    FILELGET          PROCESS THIS CARD FOR KEYWORD
         CLC   =C'LABELIMIT=',CARDIN    KEYWORD PRESENT IN THIS CARD?
         BE    LABELGET          PROCESS THIS CARD FOR KEYWORD
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* ----         Resume Checking SYSIN in PARM Table
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
CHKPARMS DS    0H                CHECK THIS CARD AGAINST PARMTABL
         ST    R7,SAVE7BA1     SAVE BAL REGISTER
         LA    R4,CARDIN       POINT PARM SEARCH TO BEGINNING OF CARD
         LA    R5,72           LOAD COLUMN LENGTH FOR SEARCH
         ST    R5,PARMSLEN     LOAD LENGTH INTO FIELD FOR ROUTINE
         L     R2,=V(PARMTABL)   POINT R2 TO PARM TABLE
         L     R1,TOTCHRCT
         A     R1,PRMCHRCT
         ST    R1,TOTCHRCT
         LA    R1,0            START SEARCH COUNT AT ZERO AGAIN
         ZAP   PARMHITS,=P'0'
         ZAP   PARMLCNT,=P'0'
         BAL   R7,PARMLOOP     CHECK THIS CARD FOR PARMS
         AP    TOTMHITS,PARMHITS
         AP    TOTMLCNT,PARMLCNT
         L     R7,SAVE7BA1     RESTORE BAL REGISTER
         B     CARDREAD        GET ANOTHER CARD
* ----
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*              Handle User Code Here for Keywords
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
FILELGET DS    0H
         CLI   CARDIN+10,C' '    IS FIRST NUMBER VALUE BLANK?
         BE    CARDREAD          YES. IGNORE ENTIRE CARD
         CLI   CARDIN+10,X'F0'   SMALLER THAN ZERO?
         BL    CARDREAD          YES. IGNORE.
         CLI   CARDIN+10,X'F9'   BIGGER THAN 9?
         BH    CARDREAD          YES. IGNORE.
         OI    PARMFLG3,X'02'    SET FILE LIMIT OPTION ON
         LA    R15,CARDIN+10     STARTING ADDRESS
         LR    R1,R15            LOAD R1 WITH THIS ADDRESS
FILELNUM DS    0H
         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER
         C     R15,=A(CARDIN+71) END OF CARD?
         BH    FILELGNM          YES, GET NUMBER
         CLI   0(R15),C' '       BLANK HERE?
         BE    FILELGNM          YES, GET NUMBER
         B     FILELNUM          NO. STEP UP ONE PLACE
FILELGNM DS    0H
         SR    R15,R1            HOW BIG IS THE NUMBER
         BCTR  R15,0             LOWER IT FOR EXECUTE
         EX    R15,PACK          COPY THE NUMBER TO WORK AREA
         EX    R15,MVLIMNUM      COPY THE NUMBER TO MESSAGE AREA
         CVB   R0,WORKA          CONVERT IT TO BINARY
         ST    R0,LINFILE        STORE THE VALUE FOR LATER USE
         MP    WORKA,PL4NO3      MULTIPLY BY 3 IF SL FILES
         CVB   R0,WORKA          CONVERT IT TO BINARY
         ST    R0,LSLFILE        STORE THE VALUE FOR LATER USE
         MVC   LTGFILE(4),LINFILE   STUFF NL VALUE IN FOR STARTERS
FILELCLG DS    0H
         B     CARDREAD
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LABELGET DS    0H
         CLI   CARDIN+10,C' '    IS FIRST NUMBER VALUE BLANK?
         BE    CARDREAD          YES. IGNORE ENTIRE CARD
         CLI   CARDIN+10,X'F0'   SMALLER THAN ZERO?
         BL    CARDREAD          YES. IGNORE.
         CLI   CARDIN+10,X'F9'   BIGGER THAN 9?
         BH    CARDREAD          YES. IGNORE.
         OI    PARMFLG4,X'10'    SET LABEL LIMIT OPTION ON
         LA    R15,CARDIN+10     STARTING ADDRESS
         LR    R1,R15            LOAD R1 WITH THIS ADDRESS
LABELNUM DS    0H
         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER
         C     R15,=A(CARDIN+71) END OF CARD?
         BH    LABELGNM          YES, GET NUMBER
         CLI   0(R15),C' '       BLANK HERE?
         BE    LABELGNM          YES, GET NUMBER
         B     LABELNUM          NO. STEP UP ONE PLACE
LABELGNM DS    0H
         SR    R15,R1            HOW BIG IS THE NUMBER
         BCTR  R15,0             LOWER IT FOR EXECUTE
         EX    R15,PACKL         COPY THE NUMBER TO WORK AREA
         EX    R15,MVLBLNUM      COPY THE NUMBER TO MESSAGE AREA
         CVB   R0,WORKL          CONVERT IT TO BINARY
         ST    R0,LINLABEL       STORE THE VALUE FOR LATER USE
LABELCLG DS    0H
         B     CARDREAD
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*              End of User Code Here for Keywords
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
CHECKEND DS    0H
* -----------------------------------------------------------
SYSINEND DS    0H
         TM    OPENDFLG,X'02'   IS SYSIN    DD OPEN?
         BZ    CARDREND         NO.  GET OUT.
         L     R1,TOTCHRCT
         A     R1,PRMCHRCT         Final totals for last card
         ST    R1,TOTCHRCT
         NI    OPENDFLG,FF-X'02'   MARK SYSIN FILE AS CLOSED
         CLOSE (SYSIN)
CARDREND DS    0H
         BAL   R7,SUMMREPT
         TM    OPENDFLG,X'01'   IS PARMREPT DD OPEN?
         BZ    PARMRPEN         NO.  GET OUT.
         NI    OPENDFLG,FF-X'01'   MARK SYSIN FILE AS CLOSED
         CLOSE (PARMREPT)
PARMRPEN DS    0H
THEEND   DS    0H
         L     R13,4(,R13)
         MVC   16(4,R13),=F'0'          Return code 0     in R15
         MVC   24(4,R13),=A(PARMFLGS)   Address of flags  in R1
         MVC   28(4,R13),=A(STRTVALU)   Address of values in R2
         LM    R14,R12,12(R13)
         BR    R14
* -----------------------------------------------------------
*        S U B R O U T I N E S
* -----------------------------------------------------------
*   NOW CHECK EACH CHARACTER IN JCL, TO SEE IF IT'S A PARM.
* -----------------------------------------------------------
PARMLOOP C     R1,PARMSLEN    PAST THE END OF PARMS?
         BNL   PARMFIN        YES - GET OUT
         L     R2,=V(PARMTABL)  POINT BACK TO BEGINNING OF TABLE
         AP    PARMLCNT,=P'1'  COUNT PARM LOOPS FOR DEBUGGING
BOPPTBL  CLI   0(R2),X'FF'    END OF PARM TABLE?
         BE    PRMNFND        YES. BUMP AND TRY AGAIN.
*        ------------------------------------------------------------
*--->                    code to require a delimiter (space, etc)
*                        to enable, comment out the next instruction
*        ------------------------------------------------------------
         B     PRMNODLM         comment this line to require delimiter
         TM    PRMFDFLG,X'01'
         BO    PRMNFND
PRMNODLM DS    0H
*--->
         XR    R5,R5          CLEAR WORK REGISTER FOR REUSE
         IC    R5,0(,R2)      LOAD LENGTH TO BE COMPARED
         BCTR  R5,0           ONE LESS FOR EXECUTE
         EX    R5,MOVPARM     MOVE CHARS TO WORK AREA TO UPPERCASE
*
*   If you want to require parm comparisons as case sensitive,
*    then comment out the following instruction....
*
         EX    R5,OCPARM      UPPERCASE WHAT YOU THINK IS THE PARM
*
         EX    R5,CMPPARM     COMPARE TABLE ENTRY TO UPPERCASED PARM
         BE    PRMFOUND       PARM FOUND AT THIS LOCATION
         LA    R2,PTELEN(,R2)  NEXT TABLE ENTRY
         B     BOPPTBL        INNER LOOP
*
PRMNFND  DS    0H
*--->                 below - Parm Found flagging to require delimiter
         CLI   0(R4),C' '     Turn off "PARM FOUND" flag if delimiters
         BE    PRMFDOFF
         CLI   0(R4),C','
         BE    PRMFDOFF
         B     PRMFDEND
PRMFDOFF DS    0H
         NI    PRMFDFLG,X'FF'-X'01'     Turn off PARM FOUND flag
PRMFDEND DS    0H
*--->                 above - Parm Found flagging to require delimiter
*
         LA    R4,1(,R4)      FORWARD IN JCL PARMS
         LA    R1,1(,R1)      MEASURE DISTANCE TRAVELED
*
         B     PARMLOOP       TRY AGAIN
*
PRMFOUND DS    0H
*
*--->                 below - Parm Found flagging to require delimiter
         OI    PRMFDFLG,X'01'    Turn on PARM FOUND flag
*--->                 above - Parm Found flagging to require delimiter
PRMNOSEP DS    0H
         AP    PARMHITS,=P'1'    COUNT PARM HITS
         MVC   PARMTENT(PTELEN),0(R2)  DUMP TABLE ENTRY FOUND
         TM    1(R2),X'01'         PARM ON OR OFF?
         BO    PARMOFF             OFF
         OC    PARMFLGS(PBYTES),PTEFLG(R2)   ON. FLAG THE PARM FOUND
         B     PARMGO                        AND GO ON
PARMOFF  MVC   PARMFWRK(PBYTES),PTEFLG(R2)   PARM BYTES TO WRK
         XC    PARMFWRK(PBYTES),EFFS         FLIP PARM BITS
         NC    PARMFLGS(PBYTES),PARMFWRK     TURN PARM BIT(S) OFF
PARMGO   DS    0H
         XR    R5,R5          Clear Work Reg befor IC
         IC    R5,0(,R2)      LENGTH OF PARM, FROM THE TABLE
         LA    R1,0(R5,R1)    INCREMENT COUNT BY LENGTH
         LA    R4,0(R5,R4)    SAME FOR SEARCH POSITION
         B     PARMLOOP       LOOK FOR MORE PARMS
PARMFIN  ST    R1,PRMCHRCT    HOW MANY CHARS WE SEARCHED --
*                             COUNT FOR DEBUGGING
PRMCHEND DS    0H
         BR    R7
MOVPARM  MVC   PARMWORK(1),0(R4)       ** EXECUTED **
OCPARM   OC    PARMWORK(1),UPCASEOR    ** EXECUTED **
CMPPARM  CLC   PARMWORK(1),2(R2)       ** EXECUTED **
* --------------------------------------------------------- *
SUMMREPT DS    0H                  Print details of PARMREPT
         TM    OPENDFLG,X'01'      Is PARMREPT DD open?
         BZ    SUMMREND            No. Bypass this routine.
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(16),=C'Parm Settings:  '
         HEX   PRTLINE+27,1,PARMFLG1
         HEX   PRTLINE+30,1,PARMFLG2
         HEX   PRTLINE+33,1,PARMFLG3
         HEX   PRTLINE+36,1,PARMFLG4
         HEX   PRTLINE+39,1,PARMFLG5
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1        And print it unformatted first.
         MVC   PRTLINE+4(12),=C'User Area : '
         HEX   PRTLINE+16,58,STRTVALU
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Length of User Area  :'
         HEX   PRTLINE+30,4,STRTVALU
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Length of last scan  :'
         HEX   PRTLINE+30,4,PARMSLEN
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Length of PARM field :'
         HEX   PRTLINE+30,4,SAVMSLEN
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Address of JCL PARMs :'
         HEX   PRTLINE+30,4,PARMSTRT
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Last Character Count :'
         HEX   PRTLINE+30,4,PRMCHRCT
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Number of PARM Chars :'
         HEX   PRTLINE+30,4,SAVCHRCT
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Total Chars Searched :'
         HEX   PRTLINE+30,4,TOTCHRCT
         MVC   PRTLINE+42(6),=C'Hex   '
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Parm hits in PARM    :'
         HEX   PRTLINE+30,4,SAVPHITS
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Parm hits last SYSIN :'
         HEX   PRTLINE+30,4,PARMHITS
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Total Parm Hits      :'
         HEX   PRTLINE+30,4,TOTMHITS
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Parm loops in PARM   :'
         HEX   PRTLINE+30,4,SAVELCNT
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Parm loops last SYSIN:'
         HEX   PRTLINE+30,4,PARMLCNT
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Total Parm Loops     :'
         HEX   PRTLINE+30,4,TOTMLCNT
         MVC   PRTLINE+42(6),=C'Packed'
         PUT   PARMREPT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(22),=C'Last Table Entry     :'
         HEX   PRTLINE+30,15,PARMTENT
         PUT   PARMREPT,PRTLINE
SUMMREND DS    0H
         BR    R7
* --------------------------------------------------------- *
* --------------------------------------------------------- *
PACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>
PACKL    PACK  WORKL,0(0,1)          <<< EXECUTED >>>
MVLIMNUM MVC   LIMFMSG+11(0),0(R1)   <<< EXECUTED >>>
MVLBLNUM MVC   LIMLMSG+11(0),0(R1)   <<< EXECUTED >>>
         EJECT
* --------------------------------------------------------- *
WORKA    DC    D'0'
WORKL    DC    D'0'
PL4NO3   DC    PL4'3'
FF       EQU   X'FF'
LIMFMSG  DC    C' FILELIMIT=           HAS BEEN CODED IN SYSIN. NUMBER'
         DC    C' IS TREATED AS NL.                                   '
         DC    CL27' '
LIMLMSG  DC    C' LABELIMIT=           HAS BEEN CODED IN SYSIN. NUMBER'
         DC    C' REFLECTS THE COUNT OF ----ENDOFLABELTRAILER CARDS.  '
         DC    CL27' '
* --------------------------------------------------------- *
PARMFLGS DS    0CL5     5 CONTIGUOUS BYTES OF PARM FLAGS
PARMFLG1 DC    X'00'
PARMFLG2 DC    X'00'
PARMFLG3 DC    X'00'
PARMFLG4 DC    X'00'
PARMFLG5 DC    X'00'
* --------------------------------------------------------- *
         DS    0F
STRTVALU DS    0CL(ENDVALUE)
         DC    A(ENDVALUE)
PARMSLEN DC    F'0'                LENGTH OF PARMS
SAVMSLEN DC    F'0'                LENGTH OF PARMS
PARMSTRT DC    F'0'                START ADDR OF JCL PARMS
PRMCHRCT DC    F'0'                CHAR COUNT FOR PRM SEARCH
SAVCHRCT DC    F'0'                CHAR COUNT FOR PRM SEARCH
TOTCHRCT DC    F'0'                CHAR COUNT FOR PRM SEARCH
SAVPHITS DC    PL4'0'              NUMBER OF PARM HITS
PARMHITS DC    PL4'0'              NUMBER OF PARM HITS
TOTMHITS DC    PL4'0'              NUMBER OF PARM HITS
SAVELCNT DC    PL4'0'              NUMBER OF PARM LOOPS
PARMLCNT DC    PL4'0'              NUMBER OF PARM LOOPS
TOTMLCNT DC    PL4'0'              NUMBER OF PARM LOOPS
PARMTENT DC    CL15' '             PARM TABLE ENTRY DUMP
         DC    CL7' '              FILLER
PARMFWRK DC    XL5'00'             FOR TURNING OFF PARM BYTES
*  -----    User Stuff
LINFILE  DC    F'0'           RAW FILE LIMIT VALUE - SAME FOR NL
LSLFILE  DC    F'0'           SL  FILE LIMIT VALUE - 3X NL VALUE
LTGFILE  DC    F'0'           TARGET NUMBER FOR FILE LIMIT VALUE
LINLABEL DC    F'0'           LABEL LIMIT VALUE
ENDVALUE EQU   *-PARMSLEN
* --------------------------------------------------------- *
*              FORMAT OF PARM TABLE
*              ONE ENTRY IS 15 BYTES
*                1ST BYTE:      LENGTH OF THIS PARM IN HEX
*                2ND BYTE:      X'01' SAYS TURN FLAG OFF
*                               X'00' SAYS TURN FLAG ON
*                               X'10' SET ENTRY AS A DEFAULT
*                NEXT 8 BYTES:  PARM NAME - LEFT JUSTIFIED
*                NEXT 5 BYTES:  FLAG SETTINGS - 5 FLAGS,
*                                WHICH ALLOWS FOR 40 PARMS
*                                THAT DON'T HAVE TO BE
*                                SEPARATED BY A COMMA.
PBYTES   EQU   5                Number of bytes of parm switches
PTELEN   EQU   15               Length of each table entry
PTEFLG   EQU   PTELEN-PBYTES    Displacement from entry to switch bytes
EFFS     DC    15X'FF'          X'FF' bytes for XORing
* --------------------------------------------------------- *
PARMTABL CSECT
         DC    X'07',X'00',C'LTMSKIP ',X'2000000000' FIRST ENTRY
         DC    X'07',X'00',C'SKIPLTM ',X'2000000000'
         DC    X'07',X'11',C'COPYLTM ',X'2000000000' DEFAULT
         DC    X'07',X'01',C'LTMCOPY ',X'2000000000'
         DC    X'07',X'00',C'LBLINFO ',X'DE00000000'
         DC    X'06',X'00',C'PRINTL  ',X'DE00000000'
         DC    X'06',X'00',C'LABELS  ',X'DE00000000'
         DC    X'06',X'01',C'NOLABL  ',X'DE00000000'
         DC    X'07',X'11',C'NOLABEL ',X'DE00000000' DEFAULT
         DC    X'04',X'00',C'HDR1    ',X'0200000000'
         DC    X'06',X'01',C'NOHDR1  ',X'0200000000'
         DC    X'04',X'00',C'HDR2    ',X'0400000000'
         DC    X'06',X'01',C'NOHDR2  ',X'0400000000'
         DC    X'04',X'00',C'EOF1    ',X'0800000000'
         DC    X'06',X'01',C'NOEOF1  ',X'0800000000'
         DC    X'04',X'00',C'EOF2    ',X'1000000000'
         DC    X'06',X'01',C'NOEOF2  ',X'1000000000'
         DC    X'04',X'00',C'EOV1    ',X'4000000000'
         DC    X'06',X'01',C'NOEOV1  ',X'4000000000'
         DC    X'04',X'00',C'EOV2    ',X'8000000000'
         DC    X'06',X'01',C'NOEOV2  ',X'8000000000'
         DC    X'04',X'00',C'HDRS    ',X'0600000000'
         DC    X'06',X'01',C'NOHDRS  ',X'0600000000'
         DC    X'04',X'00',C'EOFS    ',X'1800000000'
         DC    X'06',X'01',C'NOEOFS  ',X'1800000000'
         DC    X'04',X'00',C'EOVS    ',X'C000000000'
         DC    X'06',X'01',C'NOEOVS  ',X'C000000000'
         DC    X'06',X'00',C'CHGVOL  ',X'0001000000'
         DC    X'08',X'11',C'NOCHGVOL',X'0001000000' DEFAULT
         DC    X'06',X'00',C'JCLVOL  ',X'0001000000'
         DC    X'08',X'01',C'NOJCLVOL',X'0001000000'
         DC    X'06',X'00',C'NEWVOL  ',X'0001000000'
         DC    X'08',X'01',C'NONEWVOL',X'0001000000'
         DC    X'06',X'10',C'VOLLBL  ',X'0002000000' DEFAULT
         DC    X'08',X'01',C'NOVOLLBL',X'0002000000'
         DC    X'07',X'00',C'EOV2EOF ',X'0004000000'
         DC    X'08',X'00',C'EOVTOEOF',X'0004000000'
         DC    X'06',X'00',C'EOVCHG  ',X'0004000000'
         DC    X'08',X'11',C'NOEOVCHG',X'0004000000' DEFAULT
         DC    X'04',X'00',C'READ    ',X'0008000000'
         DC    X'08',X'00',C'READONLY',X'0008000000'
         DC    X'07',X'00',C'NOWRITE ',X'0008000000'
         DC    X'07',X'11',C'WRITE   ',X'0008000000' DEFAULT
         DC    X'08',X'00',C'LABLDUMP',X'0010000000'
         DC    X'08',X'11',C'NOLABLDU',X'0010000000' DEFAULT
         DC    X'05',X'00',C'SYSIN   ',X'0020000000'
         DC    X'07',X'11',C'NOSYSIN ',X'0020000000' DEFAULT
         DC    X'06',X'00',C'OUTVOL  ',X'0040000000'
         DC    X'08',X'00',C'NOOUTVOL',X'0040000000'
         DC    X'08',X'00',C'LABADDIN',X'0080800000' INCLUDE LBLFIX
         DC    X'08',X'01',C'NOLABADD',X'0080000000'
         DC    X'06',X'10',C'BLKCNT  ',X'0100000000' DEFAULT
         DC    X'08',X'01',C'NOBLKCNT',X'0100000000'
         DC    X'08',X'00',C'PRADDLBL',X'0000100000'
         DC    X'08',X'01',C'NOPRADDL',X'0000100000'
         DC    X'08',X'00',C'CORRBLKS',X'0000200000'
         DC    X'08',X'01',C'NOCORRBL',X'0000200000'
         DC    X'08',X'00',C'NOEXNULL',X'0000400000'
         DC    X'08',X'00',C'NOSLNULL',X'0000400000'
         DC    X'06',X'11',C'EXNULL  ',X'0000400000'
         DC    X'06',X'01',C'SLNULL  ',X'0000400000'
         DC    X'06',X'00',C'LBLFIX  ',X'0000800000'
         DC    X'08',X'01',C'NOLBLFIX',X'0000800000'
         DC    X'08',X'00',C'INITVOLS',X'0001010000'
         DC    X'08',X'00',C'INITTAPE',X'0001010000'
         DC    X'07',X'00',C'LIMFILE ',X'0000020000'
         DC    X'07',X'00',C'FILELIM ',X'0000020000'
         DC    X'08',X'01',C'NOLIMFIL',X'0000020000'
         DC    X'05',X'00',C'BYTES   ',X'0000040000'
         DC    X'07',X'01',C'NOBYTES ',X'0000040000'
         DC    X'06',X'00',C'CUMTOT  ',X'0000080000'
         DC    X'08',X'01',C'NOCUMTOT',X'0000080000'
         DC    X'08',X'00',C'LIMLABEL',X'0000001000'
         DC    X'08',X'01',C'NOLIMLAB',X'0000001000'
         DC    X'06',X'10',C'OPTION  ',X'0000002000'
         DC    X'08',X'01',C'NOOPTION',X'0000002000'
         DC    X'07',X'10',C'SUPPWTO ',X'0000004000'
         DC    X'08',X'01',C'NOSUPPWT',X'0000004000'
         DC    X'08',X'00',C'LBDQUICK',X'0000008000'
         DC    X'08',X'01',C'NOLBDQUI',X'0000008000'
         DC    X'FFFFFFFFFFFFFFFF'
* --------------------------------------------------------- *
PARMCHEK CSECT
         SPACE 3
         LTORG
         SPACE 3
         DS    0D
* --------------------------------------------------------- *
MESSAGE1 DC    CL133'1PARMCHEK - GENERALIZED PARM AND SYSIN SCANNING PR-
               OGRAM '
* --------------------------------------------------------- *
         SPACE 3
SYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X
               EODAD=SYSINEND
PARMREPT DCB   DDNAME=PARMREPT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
* --------------------------------------------------------- *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* --------------------------------------------------------- *
FLAGSYST DC    X'00'          FLAG INDICATING DCB IS PRESENT
*              X'01'          PARMREPT DD IS PRESENT
*              X'02'          SYSIN    DD IS PRESENT
OPENDFLG DC    X'00'          FLAG INDICATING DCB IS OPEN
*              X'01'          PARMREPT DD IS OPEN
*              X'02'          SYSIN    DD IS OPEN
* --------------------------------------------------------- *
         SPACE 3
PARMSAVE DC    F'0'
SAV4HEX  DC    F'0'
SAVE2TO3 DC    2F'0'
SAVE3REG DC    F'0'
SAVE7BA0 DC    F'0'
SAVE7BA1 DC    F'0'
PARMWORK DC    CL8' '
UPCASEOR DC    CL8' '
         DC    CL4' '
*    ------------------------ >   Constants for Date and Time - below
SAVE1402 DS    6F                 Extra fullword for safety
TIMED    DS    CL7
DATED    DS    CL9
DATETIME DS    4F
         ORG   DATETIME
TIME     DS    CL4
         DS    CL4
DATE     DS    CL5
         DS    CL3
HEADDLIT DS    0CL31              Literal for headings - date and time
         DC    CL6'Today:'
         DC    CL2' '
HEADDATE DC    CL23' '
LEVELLIT DS    0CL21              Level number display for headings
         DC    CL6'Level '
LEVELL   DC    CL4'&LLEV'
         DC    CL2' ('
LEVDATE  DC    CL8' '             Assembly date for this program
         DC    CL1')'
*    ------------------------ >   Constants for Date and Time - above
*    --------------- >            Output line buffers - below
PRMFDFLG DC    X'00'              Parm Found Flag
*              X'01'              Parm has been found in this record
         DC    CL3' '
         DC    C' '
LINE     DC    CL133' '
         DC    C' '
CNTLINE  DC    CL133' '
         DC    C' '
OUTLINE  DC    CL133' '
         DC    C' '
PRTLINE  DC    CL133' '
         DC    CL80' '            Padding
*    --------------- >            Output line buffers - above
*
CARDIN   DC    CL80' '            SYSIN CARD INPUT AREA
         END
